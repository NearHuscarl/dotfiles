#!/bin/env python

"""
Generate vim colorscheme file from yaml file config which is
more simple than having to create colorscheme using vimscript
"""

import argparse
import os
from pprint import pprint as p
import time
import subprocess

import yaml

# ----- module scope variables -----
# pylint: disable=global-statement
yaml_path = ''
output_path = ''

color_dict = {}
arg_list = None

default_transparent_group = ['Normal', 'LineNr', 'Folded', 'SignColumn']
transparent_group = []

valid_colors = []
valid_attr = []

# ----------------------------------

# ------- Set up -------
def get_args():
	""" Get script arguments """
	parser = argparse.ArgumentParser(
			description='Generate vim colorscheme file from simplilfied yaml config file')
	parser.add_argument('inputfile', metavar='F', type=str, nargs=1,
			help='yaml file path to parse')
	parser.add_argument('-d', '--dest', nargs='?',
			help='destination path for generated colorshceme, default is current directory',
			default=os.getcwd())
	parser.add_argument('-cg', '--callgraph', action='store_true', help='generate function call graph')
	return parser.parse_args()

def callgraph(func):
	""" decorator to generate callgraph start from the decorated function """
	def generate_callgraph(*args, **kwargs):
		""" set up before starting generate callgraph and take function func as starting point """
		from pycallgraph import PyCallGraph
		from pycallgraph import Config
		from pycallgraph.output import GraphvizOutput

		graphviz = GraphvizOutput()
		graphviz.output_file = 'colorvim.png'
		config = Config(groups=False)

		with PyCallGraph(config=config, output=graphviz):
			func(*args, **kwargs)
	return generate_callgraph

def validate_content(colorscheme):
	""" Throw error if palette or group dict is empty """
	if colorscheme['group'] is None:
		raise KeyError('Groups is empty')
	if colorscheme['palette'] is None:
		raise KeyError('Palette is empty')
	return colorscheme

def set_up(colorscheme):
	""" Make all colorname lowercase and set up some global variables """
	global color_dict
	global valid_colors
	global valid_attr

	color_dict = validate_content(colorscheme)
	color_dict['group'] = {name: val.lower()
			for name, val in colorscheme['group'].items()}
	color_dict['palette'] = {name.lower(): val
			for name, val in colorscheme['palette'].items()}

	valid_colors = list(color_dict['palette'].keys()) + ['_']
	valid_attr = ['bold', 'underline', 'undercurl', 'strikethrough', 'reverse', 'inverse',  \
			'italic', 'standout', 'nocombine', 'NONE']

#-----------------------

# ----- getter functions ------
def get_name():
	""" get colorscheme name """
	if 'name' not in color_dict or not color_dict['name']:
		raise NameError('Name field not exists or empty')
	return color_dict['name']

def get_filename():
	""" get colorscheme filename """
	return get_name() + '.vim'

def get_description():
	""" get colorscheme description (default is <colorscheme>.vim) """
	if 'description' not in color_dict or not color_dict['description']:
		return get_name() + ' colorscheme'
	return color_dict['description']

def get_author():
	""" get author name. email is optional """
	if 'author' not in color_dict or 'name' not in color_dict['author']:
		raise NameError('Author field not exists or empty')

	if 'email' not in color_dict['author'] or not color_dict['author']['email']:
		return color_dict['author']['name']

	return '{} <{}>'.format(color_dict['author']['name'], color_dict['author']['email'])


def get_last_change():
	""" Get the generated timestamp """
	return time.strftime('%a %b %d %H:%M:%S %Z %Y', time.localtime())

def get_license():
	""" get license info (optional) """
	if 'license' not in color_dict or not color_dict['license']:
		return None
	return color_dict['license']

def get_note():
	""" get colorscheme note (optional) """
	if 'note' not in color_dict or not color_dict['note']:
		return 'This colorscheme file is generated by colorvim command'
	return color_dict['note']

def get_colors(color='ALL'):
	""" get color palette as a dictionary """
	if color == 'ALL':
		return color_dict['palette']
	return color_dict['palette'][color]

def get_group_dict(group_name='ALL'):
	""" Return a dictionary which have group names maps to their values """
	if group_name == 'ALL':
		return color_dict['group']
	return color_dict['group'][group_name]

def get_background():
	""" get background value ('dark' or 'light') """
	if 'option' not in color_dict or 'background' not in color_dict['option'] \
			or not color_dict['option']['background']:
		return 'dark'
	background = color_dict['option']['background']
	if background != 'dark' and background != 'light':
		raise NameError("background option has to be either 'dark' or 'light'")
	return background

def get_term_color(color):
	""" Get ctermfg color """
	return 'NONE' if color == '_' else str(get_colors(color)[1])

def get_gui_color(color):
	""" Get guibg color """
	return 'NONE' if color == '_' else str(get_colors(color)[0])

def get_transparent_group():
	""" Get transparent groups that whose ctermbg value will be set to NONE """
	if 'option' in color_dict and color_dict['option'].get('transparent_group'):
		return color_dict['option']['transparent_group']
	return default_transparent_group

def is_transparent():
	""" Is transparent option set """
	if 'option' in color_dict and 'transparent' in color_dict['option']:
		return True if color_dict['option']['transparent'] else False
	return False

def validate_color(color, group):
	""" Check if color is in palette list, raise if it doesn't """
	if color not in valid_colors:
		raise NameError('color {} of {} is not in the color pelette'.format(color, group))

def validate_attr(attr_list, group):
	""" Check if attributes is in valid attribute keyword list, raise if it doesn't """
	for attr in attr_list:
		if attr not in valid_attr:
			raise NameError('attribute {} of {} is not a valid keyword'.format(attr, group))

def get_hi_group_color(group_name):
	""" Return a tuple contain group fg and bg color (termfg, termbg, guifg, guibg) """
	group_val = get_group_dict(group_name).split(maxsplit=2)
	fg_color, bg_color = group_val[:2]

	validate_color(fg_color, group_name)
	validate_color(bg_color, group_name)

	if is_transparent():
		termbg = 'NONE' if group_name in get_transparent_group() else get_term_color(bg_color)
	else:
		termbg = get_term_color(bg_color)
	termfg = get_term_color(fg_color)
	guibg = get_gui_color(bg_color)
	guifg = get_gui_color(fg_color)
	return (termfg, termbg, guifg, guibg)

def get_hi_group_attr(group_name):
	""" Return a tuple contain group attributes (term_attr, gui_attr) """
	group_val = get_group_dict(group_name).split(maxsplit=2)
	if group_val[2] == '_':
		return 'NONE'
	attr = group_val[2].replace(' ', '')
	attr_list = attr.split(',')

	validate_attr(attr_list, group_name)
	return attr

def get_hi_group_value(group_name):
	"""
	Return a tuple contain group attributes
	(termfg, termbg, guifg, guibg, term_attr, gui_attr)
	"""
	if len(get_group_dict(group_name).split()) < 3:
		raise ValueError('Require at least 3 values: fg color, bg color and attribute')
	return get_hi_group_color(group_name) + tuple([get_hi_group_attr(group_name)]) * 2

def get_links(link_name='ALL'):
	""" Return a list of linked groups """
	if link_name == 'ALL':
		return color_dict['link']
	return color_dict['link'][link_name]

# -----------------------------

def hex2rgb(hex_color):
	""" '#B4FBB8' => 'rgb(180, 251, 184)' """
	hex_color = hex_color.strip('#')

	rgb = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
	return 'rgb{}'.format(rgb)

def rgb2hex(rgb_color):
	""" 'rgb(180, 251, 184)' => '#B4FBB8' """
	rgb = [int(i) for i in rgb_color.strip('rgb()').split(',')]
	return '#{:02x}{:02x}{:02x}'.format(rgb[0], rgb[1], rgb[2])

def put(file, line=''):
	""" write content to a file with newline character """
	file.write(line + '\n')

def write_header():
	""" Write header content to colorscheme file """

	with open(output_path, 'w') as file:
		put(file, '" ==================================================================')
		put(file, '" File:        {}'.format(get_filename()))
		put(file, '" Description: {}'.format(get_description()))
		put(file, '" Author:      {}'.format(get_author()))
		put(file, '" Last Change: {}'.format(get_last_change()))
		if get_license():
			put(file, '" Licence:     {}'.format(get_license()))
		if get_note():
			put(file, '" Note:        {}'.format(get_note()))
		put(file, '" ==================================================================')
		put(file)

def write_palette():
	""" Write color palette to colorscheme file """
	rgb_list = [hex2rgb(color_val[0]) for color_val in get_colors().values()]
	max_rgb_len = len(max(rgb_list, key=len))
	max_name_len = len(max(get_colors().keys(), key=len))

	with open(output_path, 'a') as file:
		formatter = ('Name', 'Hex', 'Rgb', 'Xterm')
		put(file, '" {:{x}}  {:7}  {:{y}}  {}'.format(*formatter, x=max_name_len, y=max_rgb_len))
		put(file, '" ==================================================================')
		for color, val, rgb_val in zip(get_colors().keys(), get_colors().values(), rgb_list):
			formatter = (color, val[0], rgb_val, val[1])
			put(file, '" {:{x}}  {}  {:{y}}  {}'.format(*formatter, x=max_name_len, y=max_rgb_len))
		put(file)

def write_body():
	""" Write all group assignment and some logics to colorshceme file """
	with open(output_path, 'a') as file:
		put(file, 'hi clear')
		put(file)
		put(file, "if exists('syntax_on')")
		put(file, '  syntax reset')
		put(file, 'endif')
		put(file)
		put(file, "let colors_name = '{}'".format(get_name()))
		put(file, 'set background={}'.format(get_background()))
		put(file)
		put(file, "if ($TERM =~ '256' || &t_Co >= 256) || has('gui_running')")

		max_group_len = len(max(get_group_dict().keys(), key=len))
		for group in get_group_dict():
			value = get_hi_group_value(group)
			line = ('hi {:{x}} ctermfg={:4} ctermbg={:4} guifg={:7} guibg={:7} '
					'cterm={:9} gui={}').format(group, *value, x=max_group_len)
			put(file, line)

		put(file, 'endif')
		put(file)

def parse_link(link):
	""" return a tuple of from_group and to_group from an element in links list """
	return link.replace(' ', '').split('->')

def write_link():
	""" Write group link (hi link Group1 Group2) to colorscheme file """
	with open(output_path, 'a') as file:
		from_groups = [parse_link(link)[0] for link in get_links()]
		max_group_len = len(max(from_groups, key=len))
		for link in get_links():
			from_group, to_group = parse_link(link)
			line = ('hi link {:{x}} {}').format(from_group, to_group, x=max_group_len)
			put(file, line)

def indent():
	""" Indent vim colorscheme file """
	subprocess.Popen('vim ' + '+"normal! gg=G" ' + '+wqa ' + output_path, shell=True)

def parse_yaml():
	""" return object parsed from yaml file """
	with open(yaml_path, 'r') as file:
		parsed = yaml.load(file)
	return parsed

def generate(colorscheme):
	""" generate colorscheme from yaml parse result """
	set_up(colorscheme)
	write_header()
	write_palette()
	write_body()
	write_link()
	indent()

def main():
	global yaml_path
	global output_path

	yaml_path = arg_list.inputfile[0]
	colorscheme = parse_yaml()

	output_path = os.path.join(arg_list.dest, colorscheme['name'] + '.vim')
	generate(colorscheme)

if __name__ == '__main__':
	arg_list = get_args()

	if arg_list.callgraph:
		main = callgraph(main)
	main()

# TODO
# update all colorscheme with default setting for new hi group?
# test empty group value?
# link:
# test valid delimiter
# test if enough operand
# test if right hand side operand is in group list

# vim: nofoldenable
