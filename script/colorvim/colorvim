#!/bin/env python

"""
Generate vim colorscheme file from yaml file config which is
more simple than having to create colorscheme using vimscript
"""

import argparse
import os
from pprint import pprint as p
import time
import subprocess

import yaml

# ----- module scope variables -----
# pylint: disable=global-statement
yaml_path = ''
output_path = ''
color_dict = {}
arg_list = None
# ----------------------------------

# ------- Set up -------
def get_args():
	""" Get script arguments """
	parser = argparse.ArgumentParser(
			description='Generate vim colorscheme file from simplilfied yaml config file')
	parser.add_argument('inputfile', metavar='F', type=str, nargs=1,
			help='yaml file path to parse')
	parser.add_argument('-d', '--dest', nargs='?',
			help='destination path for generated colorshceme, default is current directory',
			default=os.getcwd())
	parser.add_argument('-cg', '--callgraph', action='store_true', help='generate function call graph')
	return parser.parse_args()

def callgraph(func):
	""" decorator to record callgraph start from the decorated function """
	def generate_callgraph(*args, **kwargs):
		""" set up before starting generate callgraph and take function func as starting point """
		from pycallgraph import PyCallGraph
		from pycallgraph import Config
		from pycallgraph.output import GraphvizOutput

		graphviz = GraphvizOutput()
		graphviz.output_file = 'colorvim.png'
		config = Config(groups=True)

		with PyCallGraph(config=config, output=graphviz):
			func(*args, **kwargs)
	return generate_callgraph
#-----------------------

# ----- getter functions ------
def get_name():
	""" get colorscheme name """
	if 'name' not in color_dict or not color_dict['name']:
		raise NameError('Name field not exists or empty')
	return color_dict['name']

def get_filename():
	""" get colorscheme filename """
	return get_name() + '.vim'

def get_description():
	""" get colorscheme description (default is <colorscheme>.vim) """
	if 'description' not in color_dict or not color_dict['description']:
		return get_name() + ' colorscheme'
	return color_dict['description']

def get_author():
	""" get author name. email is optional """
	if 'author' not in color_dict or 'name' not in color_dict['author']:
		raise NameError('Author field not exists or empty')

	if 'email' not in color_dict['author'] or not color_dict['author']['email']:
		return color_dict['author']['name']

	return '{} <{}>'.format(color_dict['author']['name'], color_dict['author']['email'])


def get_last_change():
	""" Get the generated timestamp """
	return time.strftime('%a %b %d %H:%M:%S %Z %Y', time.localtime())

def get_license():
	""" get license info (optional) """
	if 'license' not in color_dict or not color_dict['license']:
		return None
	return color_dict['license']

def get_note():
	""" get colorscheme note (optional) """
	if 'note' not in color_dict or not color_dict['note']:
		return None
	return color_dict['note']

def get_color():
	""" get color palette as a dictionary """
	return color_dict['palette']

def get_background():
	""" get background value ('dark' or 'light') """
	if 'option' not in color_dict or 'background' not in color_dict['option'] \
			or not color_dict['option']['background']:
		return 'dark'
	background = color_dict['option']['background']
	if background != 'dark' and background != 'light':
		raise NameError("background option has to be either 'dark' or 'light'")
	return background

def get_term_color(color):
	""" Get ctermfg color """
	return 'NONE' if color == '_' else str(color_dict['palette'][color][1])

def get_gui_color(color):
	""" Get guibg color """
	return 'NONE' if color == '_' else str(color_dict['palette'][color][0])

def get_group_attr(name):
	""" Return a tuple contain group attributes (termfg, termbg, guifg, guibg, term & gui) """
	group_attr = color_dict['group'][name].split(None, 2)
	if len(group_attr) < 2:
		raise ValueError('Require at least 2 color values for fg and bg')
	elif len(group_attr) < 3:
		fg_color, bg_color = color_dict['group'][name].split()
		attr = 'NONE'
		attr_list = []
	else:
		fg_color, bg_color, attr = color_dict['group'][name].split(None, 2)
		attr = attr.replace(' ', '')
		attr_list = attr.split(',')

	valid_colors = list(color_dict['palette'].keys()) + ['_']
	valid_attr = ['bold', 'underline', 'undercurl', 'strikethrough', 'reverse', 'inverse',  \
			'italic', 'standout', 'nocombine', 'NONE']

	if fg_color not in valid_colors:
		raise NameError('color {} of {} is not in the color pelette'.format(fg_color, name))
	if bg_color not in valid_colors:
		raise NameError('color {} of {} is not in the color pelette'.format(bg_color, name))
	for attr_ in attr_list:
		if attr_ not in valid_attr:
			raise NameError('attribute {} of {} is not a valid keyword'.format(attr_, name))

	transp_group = ['Normal', 'LineNr', 'Folded', 'SignColumn']
	if 'transparent' in color_dict['option'] and color_dict['option']['transparent'] \
			and name in transp_group:
		termbg = 'NONE'
	else:
		termbg = get_term_color(bg_color)

	termfg = get_term_color(fg_color)
	guibg = get_gui_color(bg_color)
	guifg = get_gui_color(fg_color)
	return (termfg, termbg, guifg, guibg, attr, attr)

# -----------------------------

def hex2rgb(hex_color):
	""" '#B4FBB8' => 'rgb(180, 251, 184)' """
	hex_color = hex_color.strip('#')

	rgb = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
	return 'rgb{}'.format(rgb)

def rgb2hex(rgb_color):
	""" 'rgb(180, 251, 184)' => '#B4FBB8' """
	rgb = [int(i) for i in rgb_color.strip('rgb()').split(',')]
	return '#{:02x}{:02x}{:02x}'.format(rgb[0], rgb[1], rgb[2])

def set_up():
	""" Make all colorname lowercase """
	color_dict['group'] = {name: val.lower()
			for name, val in color_dict['group'].items()}
	color_dict['palette'] = {name.lower(): val
			for name, val in color_dict['palette'].items()}

def put(file, line):
	""" write content to a file with newline character """
	file.write(line + '\n')

def write_header():
	""" Write header content to colorscheme file """

	with open(output_path, 'w') as file:
		put(file, '" ==================================================================')
		put(file, '" File:        {}'.format(get_filename()))
		put(file, '" Description: {}'.format(get_description()))
		put(file, '" Author:      {}'.format(get_author()))
		put(file, '" Last Change: {}'.format(get_last_change()))
		if get_license():
			put(file, '" Licence:     {}'.format(get_license()))
		if get_note():
			put(file, '" Note:        {}'.format(get_note()))
		put(file, '" ==================================================================')
		put(file, '')

def write_palette():
	""" Write color summary to colorscheme file """
	rgb_list = [hex2rgb(color_val[0]) for color_val in get_color().values()]
	max_rgb_len = len(max(rgb_list, key=len))
	max_name_len = len(max(get_color().keys(), key=len))

	with open(output_path, 'a') as file:
		formatter = ('Name', 'Hex', 'Rgb', 'Xterm')
		put(file, '" {:{x}}  {:7}  {:{y}}  {}'.format(*formatter, x=max_name_len, y=max_rgb_len))
		put(file, '" ==================================================================')
		for color, val, rgb_val in zip(get_color().keys(), get_color().values(), rgb_list):
			formatter = (color, val[0], rgb_val, val[1])
			put(file, '" {:{x}}  {}  {:{y}}  {}'.format(*formatter, x=max_name_len, y=max_rgb_len))
		put(file, '')

def write_body():
	""" Write all color group assignment and some logics to colorshceme file """

	with open(output_path, 'a') as file:
		put(file, 'hi clear')
		put(file, '')
		put(file, "if exists('syntax_on')")
		put(file, '  syntax reset')
		put(file, 'endif')
		put(file, '')
		put(file, "let colors_name = '{}'".format(get_name()))
		put(file, 'set background={}'.format(get_background()))
		put(file, '')
		put(file, "if ($TERM =~ '256' || &t_Co >= 256) || has('gui_running')")

		max_group_len = len(max(color_dict['group'].keys(), key=len))
		for group in color_dict['group']:
			attr = get_group_attr(group)
			line = ('hi {:{x}} ctermfg={:4} ctermbg={:4} guifg={:7} guibg={:7} '
					'cterm={:7} gui={}').format(group, *attr, x=max_group_len)
			put(file, line)

		put(file, 'endif')

def parse_yaml():
	""" return object parsed from yaml file """

	with open(yaml_path, 'r') as file:
		parsed = yaml.load(file)
	return parsed

def generate(colorscheme):
	""" generate colorscheme from yaml parse result """
	global color_dict
	color_dict = colorscheme

	set_up()
	write_header()
	write_palette()
	write_body()
	# Indent
	subprocess.Popen('vim ' + '+"normal! gg=G" ' + '+wqa ' + output_path, shell=True)

def main():
	global yaml_path
	global output_path

	yaml_path = arg_list.inputfile[0]
	colorscheme = parse_yaml()

	output_path = os.path.join(arg_list.dest, colorscheme['name'] + '.vim')
	generate(colorscheme)

if __name__ == '__main__':
	arg_list = get_args()

	if arg_list.callgraph:
		main = callgraph(main)
	main()

# TODO
# update all colorscheme with default setting for new hi group?
# test if non-exist color is filled with default color properly

# vim: nofoldenable
